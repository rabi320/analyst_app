import pandas as pd
from openai import AzureOpenAI
import re
import time
import warnings  
  
sys_msg = """
You are an AI Data Analyst assistant for DIPLOMAT DISTRIBUTORS (1968) LTD, and you are coding in Python. The following datasets are already loaded in your Python IDE:  
  
1. **DW_FACT_STORENEXT_BY_INDUSTRIES_SALES** (`stnx_sales`)  
   - **Description**: This dataset provides daily sales figures by item across different market segments.  
   - **Columns**:  
     - `Day`: Date (datetime).  
     - `Barcode`: Item identifier.  
     - `Format_Name`: Market segmentation.  
     - `Sales_NIS`: Sales amount in NIS.  
     - `Sales_Units`: Quantity sold.  
     - `Price_Per_Unit`: Daily price per unit.  
   - **Note**: Filter the data for the date range between 2024-03-01 and 2024-05-31.  
  
2. **DW_DIM_STORENEXT_BY_INDUSTRIES_ITEMS** (`stnx_items`)  
   - **Description**: This is a dimension table containing attributes of items.  
   - **Columns**:  
     - `Barcode`: Item identifier.  
     - `Item_Name`: Name of the item.  
     - `Category_Name`: Name of the category.  
     - `Sub_Category_Name`: Name of the subcategory.  
     - `Brand_Name`: Name of the brand.  
     - `Sub_Brand_Name`: Name of the sub-brand.  
     - `Supplier_Name`: Name of the supplier.  
   - **Note**: Filter the category to snacks ('חטיפים').  
  
3. **DW_CHP** (`chp`)  
   - **Description**: This fact table records daily snack prices by barcode and store, including promotions.  
   - **Columns**:  
     - `ITEM_DESCRIPION`: Name of the item.  
     - `BARCODE`: Item identifier.  
     - `CHAIN_CODE`: Supermarket chain code.  
     - `STORE_CODE`: Store code.  
     - `CHAIN`: Name of the supermarket chain.  
     - `STORE`: Name of the store.  
     - `ADDRESS`: Street and number.  
     - `CITY`: Name of the city.  
     - `SELLOUT_DESCRIPTION`: Hebrew description of sales promotions.  
     - `STORENEXT_CATEGORY`: Category name.  
     - `SUPPLIER`: Supplier name.  
     - `FILE_DATE`: Date (datetime).  
     - `PRICE`: Base price.  
     - `SELLOUT_PRICE`: Promotional price.  
     - `SALE_ID`: Identifier for a promotion.  
   - **Note**: Filter the category to snacks ('חטיפים') and the date range between 2024-03-01 and 2024-05-31.  
  
### Questions Convention:  
For any inquiries, provide answers in a Python text variable named `answer` after performing the necessary analysis. Ensure the response mimics an actual prompt generated by a large language model (LLM). Example:  

Example:
> What is the highest selling item?

```python  
# Data analysis and result retrieval...  
item = 'פרינגלס'  
answer = f'The highest selling item is {item}.' 
```

Context for Stakeholder Questions:
    -Market Cap (נתח שוק): Calculate the percentage of total sales in NIS for a brand within its category. Merge stnx_sales and stnx_items to get the required data.
    -Textual Data: All textual data is in Hebrew, so account for this when filtering DataFrames.
    -Competitors (מתחרים): The supplier name 'דיפלומט' represents the company, and other suppliers in the same category are considered competitors.
    -Promotion Sales: Actual promotions are identified where SELLOUT_PRICE in the chp dataset exceeds 1.
    -Predictive Analytics: For future event inquiries, generate forecasts using methods like SARIMA, ensuring to suppress any printed output from the chosen model.
"""

client = AzureOpenAI(
  azure_endpoint = "https://ai-usa.openai.azure.com/", 
  api_key='86bedc710e5e493290cb2b0ce6f16d80',  
  api_version="2024-02-15-preview"
)
MODEL="GPT_O"





def generate_text(prompt, sys_msg,examples = []):  
    response = client.chat.completions.create(
    model="GPT_O", # model = "deployment_name"
    messages = [{"role":"system","content":sys_msg}]+examples+[{"role":"user","content":prompt}],
    temperature=0.7,
    max_tokens=2000,
    top_p=0.95,
    frequency_penalty=0,
    presence_penalty=0,
    stop=None)
    return response.choices[0].message.content.strip()  


def extract_code(txt):
    pattern = r'```python(.*?)```'
    all_code = re.findall(pattern, txt, re.DOTALL)
    if len(all_code)==1:
        final_code = all_code[0]
    else:
        final_code = '\n'.join(all_code)
    return final_code

# Function to stream the text character by character  
def stream_text(text, delay=0.01):  
    initial_message = 'Assistant 🤖: '  
    print(initial_message, end='', flush=True)  
    time.sleep(2)
    for char in text:  
        print(char, end='', flush=True)  
        time.sleep(delay)  
    print()  # For final newline

def comment_out_lines(code,print_drop = False,data_drop = True):  
    
    
    # Define the patterns and replacements  
    lines_to_comment = [  
        "stnx_sales, stnx_items, chp = load_data()"
    ]  

    if data_drop:  
        # Comment out the specific lines  
        for line in lines_to_comment:  
            pattern = re.compile(r"^(\s*)" + line, re.MULTILINE)  
            code = pattern.sub(r"\1# " + line, code)  
        
    if print_drop:
    # Replace any print() statements with #print()  
        code = re.sub(r"^(\s*)print\(", r"\1#print(", code, flags=re.MULTILINE)  
      
    return code 


# Suppress all warnings  
warnings.filterwarnings('ignore')  

conversation_history = []

conv_cnt = 0
while True:  
    user_input = input("") 
    print(f"User 👨: {user_input}") 
    if user_input.lower() == 'exit':  
        break  
    first_prompt = False if conv_cnt>0 else True      
    conversation_history.append({'role':'user', 'content':user_input})

    
    answer = ''
    txt = ''
    
    max_attempts = 5
    errors = []
    attempts = 0  
    while attempts < max_attempts:  
        try:  
            
            txt = generate_text(sys_msg,user_input,conversation_history)
            code = extract_code(txt)
            if first_prompt:
                
                
                code = comment_out_lines(code,print_drop = True,data_drop = False)
            else:
                code = comment_out_lines(code,print_drop = True,data_drop = True)
            if attempts>0:
                code = comment_out_lines(code,print_drop = True,data_drop = True)
            
            exec(code)
            # append to history only if successfull
            conversation_history.append({'role':'assistant', 'content':txt})
            conv_cnt += 1
            break  
            # Return the result if operation is successful  
        except Exception as e:  
            errors.append(f"Attempt {attempts + 1} failed: {e}")  
            attempts += 1  
    
    sys_error = """
    You are an assistant that informs the user when their input is unclear, 
    and you ask them to provide more details or rephrase their message in the same language they used.
    """

    # generate anwer for failures
    if attempts == max_attempts:
        answer = generate_text(sys_error,user_input,conversation_history)
    



    # Stream the answer text  
    stream_text(answer, delay=0.01)   